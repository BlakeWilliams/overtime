package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
	"strings"
	"text/template"
	"unicode"

	"github.com/blakewilliams/overtime/internal/graph"
)

var builtins = map[string]bool{
	"int":     true,
	"int64":   true,
	"string":  true,
	"bool":    true,
	"float":   true,
	"float64": true,
}

type Go struct {
	graph       *graph.Schema
	PackageName string
}

func (g *Go) Endpoints() []Endpoint {
	endpoints := make([]Endpoint, 0, len(g.graph.Endpoints))
	for _, e := range g.graph.Endpoints {
		endpoints = append(endpoints, Endpoint{endpoint: e, schema: g.graph})
	}

	return endpoints
}

func (g *Go) Types() []GoType {
	types := make([]GoType, 0, len(g.graph.Types))
	for _, t := range g.graph.Types {
		types = append(types, GoType{parserType: t})
	}

	return types
}

func (g *Go) TypesNeedingResolvers() []GoResolver {
	resolvers := make([]GoResolver, 0, len(g.graph.Types))

	for _, t := range g.Types() {
		resolvers = append(resolvers, t.Resolvers()...)
	}

	return resolvers
}

func NewGo(graph *graph.Schema) *Go {
	return &Go{graph: graph, PackageName: "types"}
}

func (g *Go) Root() io.Reader {
	buf := new(bytes.Buffer)

	buf.WriteString("// This file is generated only once to bootstrap the project\n")
	buf.WriteString("// Your implementation for resolvers and endpoints should go here\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", g.PackageName))

	buf.WriteString("type RootResolver struct {}\n\n")
	buf.WriteString("var _ Resolver = (*RootResolver)(nil)\n\n")
	buf.WriteString("type RootController struct {}\n\n")
	buf.WriteString("var _ Controller = (*RootController)(nil)\n\n")

	return formatCode(buf)
}

func (g *Go) Coordinator() io.Reader {
	template, err := template.New("server").Parse(`// Code generated by github.com/blakewilliams/overtime DO NOT EDIT

	package {{.PackageName}}

	import (
		"net/http"
		"encoding/json"
	)

	// Coordinator is the main entrypoint for the server and is responsible for
	// routing requests to the correct endpoint and invoking the correct method
	// on the controller. It also handles serializing the response and calling
	// resolver methods to efficiently fetch related data.
	type Coordinator struct {
		mux 		http.ServeMux
		resolver 	Resolver
		controller 	Controller
	}

	// NewCoordinator returns a new Coordinator that passes requests to the
	// provided resolver and controller.
	func NewCoordinator(resolver Resolver, controller Controller) *Coordinator {
		c := &Coordinator{
			mux: http.ServeMux{},
			resolver: resolver,
			controller: controller,
		}

		{{ range $key, $value := .Endpoints }}
		c.mux.HandleFunc("{{.Method }} {{.Path}}", func(w http.ResponseWriter, r *http.Request) {
			result, err := c.controller.{{ .MethodName }}(w, r)
			if err != nil {
				w.WriteHeader(http.StatusInternalServerError)
			}
			{{ if .ResolverMethod }}
				{{ .ResolverMethod }}
			{{ end }}

			w.WriteHeader(http.StatusOK)
			w.Header().Set("Content-Type", "application/json")
			err = json.NewEncoder(w).Encode(result)
			if err != nil {
				w.WriteHeader(http.StatusInternalServerError)
			}
		})
		{{ end }}

		return c
	}

	// ServeHTTP serves the provided request by routing it to the correct
	// endpoint and invoking the correct method on the controller.
	func (c *Coordinator) ServeHTTP(w http.ResponseWriter, r *http.Request) {
		c.mux.ServeHTTP(w, r)
	}

	/*******************************************************************************************
	* Controllers generated here
	*******************************************************************************************/

	type Controller interface {
		{{ range $key, $value := .Endpoints }}
			{{- if .Comment }}
		 	{{- .Comment }}
			{{ end }}

			{{- .MethodName }}(w http.ResponseWriter, r *http.Request) ({{ .ReturnValue }}, error)
		{{ end }}
	}

	/*******************************************************************************************
	* Types generated here
	*******************************************************************************************/

	{{ range $key, $value := .Types }}
		type {{ .Name }} struct {
			{{ range $field := .Fields }}
				{{- if $field.Comment }}
				{{- $field.Comment }}
				{{ end }}
				{{- $field.Name }} {{ $field.Type }} {{ $field.Tags }}
			{{ end }}
		}

		{{ if .NeedsResolver }}
		func ResolveFor{{ .Name }}(records []*{{ .Name }}, resolver Resolver) (error) {
			ids := make([]int64, len(records))
			recordsMap := make({{.MapType }}, len(records))

			for i, record := range records {
				ids[i] = record.ID
				recordsMap[record.ID] = record
			}

			{{ range $field := .Fields }}
				{{ if not $field.IsBuiltin }}
					res, err := resolver.{{ $field.ResolverMethodName }}(ids)
					if err != nil {
						return err
					}

					for id, record := range recordsMap {
						if val, ok := res[id]; ok {
							record.{{ $field.Name }} = val
						}
					}
				{{ end }}
			{{ end }}

			return nil
		}
		{{ end }}
	{{ end }}

	/*******************************************************************************************
	* Resolvers generated here
	*******************************************************************************************/

	type Resolver interface {
		{{ range $key, $value := .Resolvers }}
			{{- if .Comment }}
			{{- .Comment }}
			{{ end }}
			{{- .MethodName }}({{ .Arguments }}) ({{ .ReturnType }}, error)
		{{ end }}
	}
	`)

	if err != nil {
		panic(fmt.Errorf("failed to generate server template: %w", err))
	}

	buf := new(bytes.Buffer)

	err = template.Execute(buf, map[string]interface{}{
		"PackageName": g.PackageName,
		"Endpoints":   g.Endpoints(),
		"Types":       g.Types(),
		"Resolvers":   g.TypesNeedingResolvers(),
	})

	if err != nil {
		panic(fmt.Errorf("failed to execute server template: %w", err))
	}

	return formatCode(buf)
}

func uncapitalize(s string) string {
	if len(s) == 0 {
		return s
	}

	r := []rune(s)

	return string(append([]rune{unicode.ToLower(r[0])}, r[1:]...))
}

func capitalize(s string) string {
	if len(s) == 0 {
		return s
	}

	r := []rune(s)

	return string(append([]rune{unicode.ToUpper(r[0])}, r[1:]...))
}

func formatCode(b *bytes.Buffer) io.Reader {
	formatted, err := format.Source(b.Bytes())
	if err != nil {
		fmt.Println(b.String())
		panic(err)
	}

	return bytes.NewReader(formatted)
}

func formatComment(s string) string {
	if s == "" {
		return ""
	}

	comment := strings.Builder{}
	parts := strings.Split(s, " ")

	width := 0
	for _, part := range parts {
		if width == 0 {
			comment.WriteString("// ")
		}

		switch {
		case width == 0:
			comment.WriteString(part)
		case width+len(part) > 80:
			comment.WriteString("\n")
			comment.WriteString("// ")
			comment.WriteString(part)
		default:
			comment.WriteString(" " + part)
		}

		width += len(part)
	}

	return comment.String()
}
