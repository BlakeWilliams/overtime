package generator

import (
	"bytes"
	"fmt"
	"io"
	"strings"
	"unicode"

	"github.com/blakewilliams/overtime/internal/parser"
)

var builtins = map[string]bool{
	"int":     true,
	"int64":   true,
	"string":  true,
	"bool":    true,
	"float":   true,
	"float64": true,
}

type Go struct {
	graph       *parser.Graph
	PackageName string
}

func NewGo(graph *parser.Graph) *Go {
	return &Go{graph: graph, PackageName: "types"}
}

func (g *Go) Root() io.Reader {
	buf := new(bytes.Buffer)

	buf.WriteString("// This file is generated only once to bootstrap the project\n")
	buf.WriteString("// Your implementation for resolvers and endpoints should go here\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", g.PackageName))

	buf.WriteString("type RootResolver struct {}\n\n")
	buf.WriteString("var _ Resolver = (nil)(*RootResolver)\n\n")
	buf.WriteString("type RootController struct {}\n\n")
	buf.WriteString("var _ Controller = (nil)(*RootController)\n\n")

	return buf
}

func (g *Go) Endpoints() io.Reader {
	buf := new(bytes.Buffer)

	buf.WriteString("// Code generated by overtime generator DO NOT EDIT\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", g.PackageName))

	buf.WriteString("type Controller interface {\n")
	for _, e := range g.graph.Endpoints {
		methodName := fmt.Sprintf(
			"%s%s",
			capitalize(strings.ToLower(e.Method)),
			capitalize(e.Name),
		)

		buf.WriteString(
			fmt.Sprintf(
				"\t%s(w http.ResponseWriter, r *http.Request) (%s, error)\n",
				methodName,
				e.Returns,
			),
		)

		buf.WriteString("}\n")
	}

	return buf
}

func (g *Go) Types() io.Reader {
	buf := new(bytes.Buffer)

	buf.WriteString("// Code generated by overtime generator DO NOT EDIT\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", g.PackageName))

	for _, t := range g.graph.Types {
		buf.WriteString(fmt.Sprintf("type %s struct {\n", capitalize(t.Name)))

		for _, f := range t.Fields {
			name := f.Name
			if name == "id" {
				name = "ID"
			} else {
				name = capitalize(f.Name)

			}
			buf.WriteString(fmt.Sprintf("\t%s %s `json:\"%s\"`\n", name, f.Type, f.Name))
		}

		buf.WriteString("}\n\n")
	}

	return buf
}

func (g *Go) Resolvers() io.Reader {
	buf := new(bytes.Buffer)
	buf.WriteString("// Code generated by overtime generator DO NOT EDIT\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", g.PackageName))

	addedResolvers := map[string]bool{}

	buf.WriteString("type Resolver interface {\n")

	for _, t := range g.graph.Types {
		for _, f := range t.Fields {
			normalizedType := strings.TrimPrefix(f.Type, "[]")
			if addedResolvers[normalizedType] || builtins[normalizedType] {
				continue
			}

			if _, isCustomType := g.graph.Types[normalizedType]; !isCustomType {
				continue
			}

			// TODO panic if id field is not present
			idType := t.Fields["id"].Type

			arguments := fmt.Sprintf(
				"%sIDs []%s",
				uncapitalize(t.Name),
				idType,
			)

			buf.WriteString(
				fmt.Sprintf(
					"\tResolve%s%s(%s) map[%s]%s\n",
					capitalize(t.Name),
					capitalize(f.Name),
					arguments,
					idType,
					capitalize(f.Name),
				),
			)
		}
	}

	buf.WriteString("}\n\n")

	return buf
}

func uncapitalize(s string) string {
	if len(s) == 0 {
		return s
	}

	r := []rune(s)

	return string(append([]rune{unicode.ToLower(r[0])}, r[1:]...))
}

func capitalize(s string) string {
	if len(s) == 0 {
		return s
	}

	r := []rune(s)

	return string(append([]rune{unicode.ToUpper(r[0])}, r[1:]...))
}
